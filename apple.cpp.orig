#include "DxLib.h"
#include <stdio.h>
#include <iostream>
#define _USE_MATH_DEFINES
#include <math.h>
#include <wingdi.h>

#pragma warning(disable : 4244)
#pragma warning(disable : 26812)
#pragma warning(disable : 26451)

#define SELECT_ITEM 5
#define WIDTH 970	//画面横サイズ
#define HEIGHT 600	//画面縦サイズ
/********************************************************************
* 列挙体の宣言
********************************************************************/
enum GAME_MODE {
	GAME_TITLE,
	GAME_INIT,
	GAME_END,
	GAME_MAIN,
	GAME_RESULT,
	GAME_OVER,
	END = 99
};

/********************************************************************
* 定数の宣言
********************************************************************/

<<<<<<< HEAD
/********************************************************************
* 構造体の宣言
********************************************************************/
typedef struct {
	int x1, y1,x2,y2;
	int w, h;
}Cursor;

typedef struct {
	int x, y;
	int w, h;
	int img;
	int main_img;
}Selectitem;
=======


/*******************************************************************
*画像のあれ
********************************************************************/
int g_TitleImage;				//タイトル画像
int g_BattleImage;				//戦闘画面背景
int g_SelectImage;				//キャラ選択画像
int g_EndImage;

int g_HorrorImage[4];			//ホラーキャラの画像


/********************************************************************
* 変数の宣言
********************************************************************/
//int g_OldKey;						// 前回の入力キー
//int g_NowKey;						// 今回の入力キー
//int g_KeyFlg;						// 入力キー情報
int g_key[256];						// キーの情報を格納するやつ
bool left[2], right[2], up[2], down[2],jump[2],XButton[2],YButton[2];				// キーの押下判定(添え字で判定：0が1Ｐ、1が2Ｐ)

int g_OldMouse;				//前回のマウス
int g_NowMouse;				//今回のマウス
int g_MouseFlg;				//マウスフラグ
int g_MouseX;				// マウスのX座標
int g_MouseY;				// マウスのY座標
bool mleft, mright;			// マウスの入力判定

int g_GameState;			//ゲームのシーン管理


/*サウンド*/


/********************************************************************
* 構造体の宣言
********************************************************************/
struct chara{
	int hp=100;						//体力
	int ap=0;						//アビリティのゲージ用
	float px=400, py=400;			//キャラの座標
	bool aFlg=false;				//アビリティ発動フラグ
	float jumpForce=8.0f;			//ジャンプ力
	int vector=0;					//進行ベクトル
	int oldVec = 0;					//前のベクトル
	float speed = 0;				//キャラのスピード
};

struct chara charaA[11];
struct chara charaB[11];
>>>>>>> 669c2fe6e6244ea9beb5fdd560a24b5fde0015bd

/***********************************************
  * 関数のプロトタイプ宣言
***********************************************/
// ゲーム初期化処理
void GameInit(void);
<<<<<<< HEAD
// ゲームメイン処理
void GameMain(void);
=======

// キャラ選択シーン
void GameSelect(void);

// 戦闘シーン
void GameBattle(void);
void PlayerMove(int genre,struct chara *chara,int pl);

>>>>>>> 669c2fe6e6244ea9beb5fdd560a24b5fde0015bd
// ゲームタイトル描画処理
void DrawGameTitle(void);
// エンド描画処理
void DrawEnd(void);
// ゲームクリアーの処理
void DrawGameResult(void);
// ゲームオーバー描画処理
void DrawGameOver(void);
//キー読み込み
int UpdatKey();
//ステージセレクト画面
void Stageselect(void);
void StageselectDraw(void);

// 画像読み込み
int LoadImages();

//サウンド
int LoadSounds(void);

/********************************************************************
* 変数の宣言
********************************************************************/
int g_OldKey;    // 前回の入力キー
int g_NowKey;    // 今回の入力キー
int g_KeyFlg;    // 入力キー情報
int Key[256];//キーが押されているフレーム数を格納

int g_MouseX;    // マウスのX座標
int g_MouseY;    // マウスのY座標

int g_GameState = GAME_INIT;

int haikeiA;//背景格納変数
int selectnum;

Cursor cursor;
Selectitem sitem[SELECT_ITEM];


/*サウンド*/
/*****************************************************
 * プログラムの開始
 ****************************************************/
int WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_
	HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nShowCmd) {


	SetMainWindowText("Comin"); // タイトルを設定

	ChangeWindowMode(TRUE);   // ウィンドウモードで起動
	SetGraphMode(WIDTH, HEIGHT, 32);


	if (DxLib_Init() == -1)   // DXライブラリの初期化処理
		return -1;

	SetDrawScreen(DX_SCREEN_BACK); // 描画先画面を裏にする

	// 画像読み込み
	if (LoadImages() == -1)
		return -1;

	//サウンド読み込み
	if (LoadSounds() == -1)
		return -1;

	// ゲームループ
<<<<<<< HEAD
	while (ProcessMessage() == 0 && g_GameState != END && !(g_KeyFlg & PAD_INPUT_START)) {


		// 入力キー取得
		g_OldKey = g_NowKey;
		g_NowKey = GetMouseInput();
		g_KeyFlg = g_NowKey & ~g_OldKey;
=======
	while (ProcessMessage() == 0 && g_GameState != END/* && !(g_KeyFlg & PAD_INPUT_START)*/) {

		//マウスの取得
		g_OldMouse = g_NowMouse;								//前フレームのキー取得
		g_NowMouse = GetMouseInput();							//現フレームの取得
		g_MouseFlg = g_NowMouse & ~g_OldMouse;					//マウスのフラグ
		GetMousePoint(&g_MouseX, &g_MouseY);					//マウスの位置を取得


		KeyInput();			//キーの入力を管理
>>>>>>> 669c2fe6e6244ea9beb5fdd560a24b5fde0015bd

		//マウスの位置を取得
		GetMousePoint(&g_MouseX, &g_MouseY);

		ClearDrawScreen();  // 画面の初期化

		switch (g_GameState) {

		case GAME_TITLE:DrawGameTitle(); break;		 //ゲームタイトル処理

		case GAME_INIT: GameInit();  break;			 //ゲーム初期処理

		case GAME_END: DrawEnd();  break;			 //ランキング描画処理

		case GAME_MAIN: GameMain();  break;			 //エンド描画処理

		case GAME_RESULT:DrawGameResult(); break;		 //ゲームメイン処理

		case GAME_OVER: DrawGameOver(); break;		 // ゲームオーバー描画処理

		case GAME_END:		DrawEnd(); break;		 // ゲームオーバー描画処理

		}

		ScreenFlip();    // 裏画面の内容を表画面に反映

	}

	DxLib_End(); // DXライブラリ使用の終了処理

	return 0; // ソフトの終了
}

/********************************************************************
* ゲームタイトル描画処理(メニュー画面)
********************************************************************/
void DrawGameTitle(void) {

<<<<<<< HEAD
=======

	//タイトルの画像表示
	DrawExtendGraph(0, 0,1440,810, g_TitleImage, true);
	//DrawString();

	// シーンを切り替える
	if (g_MouseFlg & MOUSE_INPUT_LEFT) {
		if ((g_MouseX > 400)
			&& (g_MouseX < 570)
			&& (g_MouseY > 600)
			&& (g_MouseY < 650)) {

			g_GameState = GAME_INIT; // ゲームスタートの選択
			//StopSoundMem(g_TitleBGM);
		}
		else if ((g_MouseX > 970)
			&& (g_MouseX < 1140)
			&& (g_MouseY > 600)
			&& (g_MouseY < 650)) {

			g_GameState = GAME_END;  // ゲームエンドの選択
			//StopSoundMem(g_TitleBGM);
		}
	}

	
	DrawBox(400,600,570,650,0x0000ff,false);
	DrawBox(970,600,1140,650,0x0000ff,false);

>>>>>>> 669c2fe6e6244ea9beb5fdd560a24b5fde0015bd
}

/********************************************************************
* ゲーム初期化処理
********************************************************************/
void GameInit(void) {
<<<<<<< HEAD
	//項目初期化
	for (int i = 0; i < 4; i++) {
		sitem[i].x = 40;
		sitem[i].y = (80*i)+20; //+20は余白
		sitem[i].w = 300;
		sitem[i].h = 60;
	}
	sitem[4].x = 40;
	sitem[4].y = 550;

	g_GameState = GAME_MAIN;
=======
	charaA->jumpForce = 8.0f;
	charaB->jumpForce = 8.0f;
	charaB->px = 840.0f;
	charaA->speed = 5.0f;
	g_GameState = GAME_SELECT;
>>>>>>> 669c2fe6e6244ea9beb5fdd560a24b5fde0015bd
}


/********************************************************************
* ゲームエンド描画処理
********************************************************************/
void DrawEnd(void) {
	SetFontSize(50);
	//DrawString(705,405,"ゲームを終了します",0xffffff,1);
	DrawGraph(0, 0, g_EndImage, FALSE);
	g_GameState = END;
}

/********************************************************************
* ゲームメイン
********************************************************************/
<<<<<<< HEAD
void GameMain(void) {
	UpdatKey();
	Stageselect();
	StageselectDraw();
=======
void GameSelect(void) {
	DrawExtendGraph(0, 0, 1440, 810, g_SelectImage, true);

	if (jump[0]) {
		g_GameState = GAME_BATTLE;
	}
}

/********************************************************************
*							戦闘シーン								*
*-------------------------------------------------------------------*
* GameBattle void型　[引数無し]										*
* PlayerDisp void型　[ジャンル番号、構造体データ、プレイヤー]		*
********************************************************************/


//関数の宣言
void HorrorMotion(struct chara* chara, int pl);
int HitCheck(float x,float y,float x2,float y2,int pl);
void subHP(int pl);

void GameBattle(void) {

	const int P1 = 0, P2 = 1;

	//背景
	DrawExtendGraph(0, 0, 1440, 810, g_BattleImage, true);

	//UI
	DrawBox(5,5,5 + charaA[Genre::HORROR].hp * 5,25,0xffff00,1);
	DrawBox(1435,5,1435 - charaB[Genre::HORROR].hp * 5,25,0xffff00,1);

	PlayerMove(Genre::HORROR, charaA ,P1);
	PlayerMove(Genre::HORROR, charaB ,P2);

}

void PlayerMove(int Gnum,struct chara *chara,int pl) {
	
	float gravity = 3.0f;
	
	DrawExtendGraph(chara->px,chara->py,chara->px + 200,chara->py + 200,g_HorrorImage[pl],true);

	//移動処理
	/*if (left[pl]) { chara->px -= 1.5f; }
	if (right[pl]) { chara->px += 1.5f; }*/

	DrawFormatString(100,200,0xff0000,"vec  = %d",charaA->vector);
	DrawFormatString(100,230,0xff0000,"vecO = %d",charaA->oldVec);
	DrawFormatString(100,260,0xff0000,"spd  = %f",charaA->speed);

	if (chara->vector != 0) {
		chara->speed -= 0.03f;
		if (chara->speed <= 0.0f) { chara->speed = 5.0f; chara->oldVec = chara->vector; chara->vector = 0; }
	}
	chara->px += chara->speed * chara->vector;


	if (up[pl])		chara->hp++;
	if (chara->hp > 100) chara->hp = 100;
	if (down[pl])	chara->hp--;
	if (chara->hp < 0) { chara->hp = 0; g_GameState = GAME_RESULT; }

	//ジャンプ処理
	if (jump[pl]) {
		
		SetFontSize(30);
		DrawString(chara->px -50, chara->py-35, "＼あははははは／", 0xff0000, 1);
		chara->py -= (chara->jumpForce - gravity);
		chara->jumpForce -= 0.1f;
		
		if (chara->py > 400.0f) {
			chara->py = 400.0f;
			chara->jumpForce = 8.0f;
			jump[pl] = false;
		}

	}

	//攻撃
	if (XButton[pl]) {
		HorrorMotion(chara,pl);
		subHP(1 - pl);
		XButton[pl] = false;
	}

	
>>>>>>> 669c2fe6e6244ea9beb5fdd560a24b5fde0015bd
}

////関数の宣言
//void HorrorMotion(struct chara* chara, int pl);
//int HitCheck();


//変数の宣言
int g_MotionCount;

void HorrorMotion(struct chara* chara, int pl) {


	if (g_MotionCount <= 20) {
		if (pl == 0)DrawBox(chara->px + 120, chara->py + 80, chara->px + 120 + 50, chara->py + 120 + 20, 0xffffff, false);
		if (pl == 1)DrawBox(chara->px + 80, chara->py + 80, chara->px + 80 - 50, chara->py + 120 + 20, 0xffffff, false);
	}
	else { g_MotionCount = 0; XButton[pl] = false; }

	if(pl == 0)HitCheck(chara->px + 120, chara->py + 80, chara->px + 120 + 50, chara->py + 120 + 20,pl);
	if(pl == 1)HitCheck(chara->px + 30, chara->py + 80, chara->px + 30 + 50, chara->py + 120 + 20,pl);

	g_MotionCount++;

}

int HitCheck(float x, float y, float x2, float y2,int pl) {

	

	return 0;
}

void subHP(int pl) {
	switch (pl) {
		case 0:
			charaA->hp-=30;
			break;

		case 1:
			charaB->hp-=30;
			break;
	}
}


/********************************************************************
* ゲームクリア描画処理
********************************************************************/
void DrawGameResult(void) {

	SetFontSize(45);
	DrawString(720,405,"1Ｐの勝ち!!",0x00ff00,1);

}

/********************************************************************
* ゲームオーバー描画処理
********************************************************************/
void DrawGameOver(void) {


<<<<<<< HEAD
=======
/********************************************************************
* キー入力管理
********************************************************************/
void KeyInput() {

	//プレイヤー1用
	static int OldKey1, NowKey1 = GetJoypadInputState(DX_INPUT_PAD1), KeyFlg1;
	OldKey1 = NowKey1;									//前フレームのキー取得
	NowKey1 = GetJoypadInputState(DX_INPUT_PAD1);		//現フレームのキー取得
	KeyFlg1 = NowKey1 & ~OldKey1;						//キーフラグ

	if (NowKey1 & PAD_INPUT_LEFT) 
	{
		charaA->speed = 5.0f;
		left[0] = true; charaA->vector = -1; 
	}
	else if (NowKey1 & PAD_INPUT_RIGHT)
	{
		charaA->speed = 5.0f;
		right[0] = true; charaA->vector = 1;
	}
	else { left[0] = false; right[0] = false; charaA->oldVec = charaA->vector; /*charaA->vector = 0;*/ }
	if (NowKey1 & PAD_INPUT_UP)			up[0] = true;		else    up[0] = false;
	if (NowKey1 & PAD_INPUT_DOWN)		down[0] = true;		else  down[0] = false;
	if (KeyFlg1 & PAD_INPUT_A)			jump[0] = true;
	if (KeyFlg1 & PAD_INPUT_3)			XButton[0] = true;
	if (KeyFlg1 & PAD_INPUT_4)			YButton[0] = true;

	//プレイヤー2用
	//static int OldKey2, NowKey2 = GetJoypadInputState(DX_INPUT_PAD2), KeyFlg2;
	//OldKey2 = NowKey2;									//前フレームのキー取得
	//NowKey2 = GetJoypadInputState(DX_INPUT_PAD2);		//現フレームのキー取得
	//KeyFlg2 = NowKey2 & ~OldKey2;						//キーフラグ

	//if (NowKey2 & PAD_INPUT_LEFT)		left[1] = true;		else  left[1] = false;
	//if (NowKey2 & PAD_INPUT_RIGHT)		right[1] = true;	else right[1] = false;
	//if (NowKey2 & PAD_INPUT_UP)			up[1] = true;		else    up[1] = false;
	//if (NowKey2 & PAD_INPUT_DOWN)		down[1] = true;		else  down[1] = false;
	//if (KeyFlg2 & PAD_INPUT_A)			jump[1] = true;
	//if (KeyFlg2 & PAD_INPUT_3)			XButton[1] = true;
	//if (KeyFlg2 & PAD_INPUT_4)			YButton[1] = true;

	if (g_NowMouse & MOUSE_INPUT_LEFT)	mleft = true;	else mleft = false;
	if (g_NowMouse & MOUSE_INPUT_RIGHT) mright = true;	else mright = false;
>>>>>>> 669c2fe6e6244ea9beb5fdd560a24b5fde0015bd
}


/********************************************************************
* 画像読み込み
********************************************************************/
int LoadImages() {

<<<<<<< HEAD
	//// タイトル
	//if ((g_TitleImage = LoadGraph("images/title.png")) == -1)return -1;
=======
	FILE* soiya;
	fopen_s(&soiya,"soiya.txt", "w");

	//タイトル
	if ((g_TitleImage = LoadGraph("images/Title.png")) == -1) { 
		fwrite("タイトルの画像読み込みでエラー", sizeof(char),50, soiya);
		return -1;
	}

	//戦闘
	if ((g_BattleImage = LoadGraph("images/戦闘背景.png")) == -1) {
		fwrite("戦闘背景読み込みでエラー", sizeof(char), 50, soiya);
		return -1;
	}

	//キャラの画像
	if ((g_HorrorImage[0] = LoadGraph("images/ホラーキャラ.png")) == -1) {
		fwrite("ホラーキャラ画像読み込みでエラー", sizeof(char), 50, soiya);
		return -1;
	}

	if ((g_HorrorImage[1] = LoadGraph("images/ホラーキャラ逆.png")) == -1) {
		fwrite("ホラーキャラ画像読み込みでエラー", sizeof(char), 50, soiya);
		return -1;
	}

	if ((g_SelectImage = LoadGraph("images/SadaoSelect.jpg")) == -1) {
		fwrite("キャラ選択画像読み込みでエラー", sizeof(char), 50, soiya);
		return -1;
	}

	if ((g_EndImage = LoadGraph("images/end.png")) == -1) {
		fwrite("終わりの画像読み込みでエラー", sizeof(char), 50, soiya);
		return -1;
	}

>>>>>>> 669c2fe6e6244ea9beb5fdd560a24b5fde0015bd

	////ステージ
	//if ((g_StageImage = LoadGraph("images/stage.png")) == -1)return -1;

	////ゲームクリア
	//if ((g_GameClearImage = LoadGraph("images/gameclear.png")) == -1)return -1;

	////ゲームオーバー
	//if ((g_GameOverImage = LoadGraph("images/gameover.png")) == -1)return -1;

	////ブロック画像
	//if (LoadDivGraph("images/block.png", 10, 10, 1, 48, 48, g_BlockImage) == -1)return -1;

	////ナンバー画像の読み込み
	//if (LoadDivGraph("images/number.png", 10, 10, 1, 60, 120, g_NumberImage) == -1)return -1;

	//背景読み込み
	if ((haikeiA = LoadGraph("images/stageselect_backtest.png")) == -1)return -1;
	if ((sitem[0].img = LoadGraph("images/test1.png")) == -1)return -1;
	if ((sitem[1].img = LoadGraph("images/test2.png")) == -1)return -1;
	if ((sitem[2].img = LoadGraph("images/test3.png")) == -1)return -1;
	if ((sitem[3].img = LoadGraph("images/test4.png")) == -1)return -1;
	if ((sitem[4].img = LoadGraph("images/back.png")) == -1)return -1;

	if ((sitem[0].main_img = LoadGraph("images/image.png")) == -1)return -1;
	if ((sitem[1].main_img = LoadGraph("images/maintest2.png")) == -1)return -1;
	if ((sitem[2].main_img = LoadGraph("images/maintest3.png")) == -1)return -1;
	if ((sitem[3].main_img = LoadGraph("images/maintest4.png")) == -1)return -1;

	return 0;
}

/********************************************************************
* サウンド読み込み
********************************************************************/
int LoadSounds(void) {

	////タイトル
	//if ((g_TitleBGM = LoadSoundMem("sounds/muci_hono_r01.mp3")) == -1)return -1;
	////クリア
	//if ((g_GameClearSE = LoadSoundMem("sounds/muci_fan_06.mp3")) == -1)return -1;
	////オーバー
	//if ((g_GameOverSE = LoadSoundMem("sounds/muci_bara_07.mp3")) == -1)return -1;
	////マウスクリック
	//if ((g_ClickSE = LoadSoundMem("sounds/ta_ta_warekie02.mp3")) == -1)return -1;
	////ブロック消去
	//if ((g_TitleBGM = LoadSoundMem("sounds/ani_ta_biyon02.mp3")) == -1)return -1;
	////ブロック移動
	//if ((g_TitleBGM = LoadSoundMem("sounds/ta_ta_doron01.mp3")) == -1)return -1;



	return 0;
}
int UpdatKey() {
	char tmpKey[256];
	GetHitKeyStateAll(tmpKey);
	for (int i = 0; i < 256; i++) {
		if (tmpKey[i] != 0) {
			Key[i]++;
		}
		else {
			Key[i] = 0;
		}
	}
	return 0;
}
void Stageselect(void) {
	//キーで選択
	if (Key[KEY_INPUT_RETURN] == 1) {
		//g_GameState=
	}
	if (Key[KEY_INPUT_DOWN] == 1) {
		selectnum = (selectnum + 1) % SELECT_ITEM;
	}
	if (Key[KEY_INPUT_UP] == 1) {
		selectnum = (selectnum + 4) % SELECT_ITEM;
	}
	if(Key[KEY_INPUT_DOWN] == 1|| Key[KEY_INPUT_UP] == 1){
		for (int i = 0; i < SELECT_ITEM; i++) {
			if (i == selectnum) {
				sitem[i].x = 80;
			}
			else {
				sitem[i].x = 40;
			}
		}
	}
	//マウス選択
	if (g_KeyFlg & MOUSE_INPUT_LEFT) {
		for (int i = 0; i < SELECT_ITEM; i++) {
			sitem[i].x = 40;
		}
		if (g_MouseX > 40 && g_MouseX < 340 && g_MouseY>20 && g_MouseY < 80) {
			selectnum = 0;
			sitem[0].x = 80;
		}
		else if (g_MouseX > 40 && g_MouseX < 340 && g_MouseY>100 && g_MouseY <160 ) {
			selectnum = 1;
			sitem[1].x = 80;
		}
		else if (g_MouseX > 40 && g_MouseX < 340 && g_MouseY>180 && g_MouseY <240 ) {
			selectnum = 2;
			sitem[2].x = 80;
		}
		else if (g_MouseX > 40 && g_MouseX < 340 && g_MouseY>260 && g_MouseY < 340) {
			selectnum = 3;
			sitem[3].x = 80;
		}
		//戻るボタン
		else if (g_MouseX > 40 && g_MouseX < 190 && g_MouseY>550 && g_MouseY < 600) {
			//g_GameState =
		}
	}
}
void StageselectDraw(void) {
	DrawGraph(0,0,haikeiA,TRUE);
	for (int i = 0; i < SELECT_ITEM; i++) {
		DrawGraph(sitem[i].x, sitem[i].y, sitem[i].img, FALSE);
	}
	DrawGraph(445,100,sitem[selectnum].main_img, FALSE);
	//DrawFormatString(500, 300, GetColor(255, 255, 0), "X %d", g_MouseX);
	//DrawFormatString(500, 400, GetColor(255, 255, 0), "Y %d",g_MouseY);
	/*SetFontSize(50);
	DrawFormatString(480, 20, GetColor(255, 255, 0), "ステージセレクト");*/
	//for (int i = 0; i < SELECT_ITEM; i++) {
	////	DrawFormatString(600, 100*i, GetColor(255, 255, 0), "Y %d", sitem[i].y);
	//}
}